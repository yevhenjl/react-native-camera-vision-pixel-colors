///
/// PixelColorsResult.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

import Foundation
import NitroModules

/**
 * Represents an instance of `PixelColorsResult`, backed by a C++ struct.
 */
public typealias PixelColorsResult = margelo.nitro.cameravisionpixelcolors.PixelColorsResult

public extension PixelColorsResult {
  private typealias bridge = margelo.nitro.cameravisionpixelcolors.bridge.swift

  /**
   * Create a new instance of `PixelColorsResult`.
   */
  init(uniqueColorCount: Double, topColors: [ColorInfo], brightestColors: [ColorInfo], motion: MotionResult?, roiApplied: Bool?, totalPixelsAnalyzed: Double?) {
    self.init(uniqueColorCount, { () -> bridge.std__vector_ColorInfo_ in
      var __vector = bridge.create_std__vector_ColorInfo_(topColors.count)
      for __item in topColors {
        __vector.push_back(__item)
      }
      return __vector
    }(), { () -> bridge.std__vector_ColorInfo_ in
      var __vector = bridge.create_std__vector_ColorInfo_(brightestColors.count)
      for __item in brightestColors {
        __vector.push_back(__item)
      }
      return __vector
    }(), { () -> bridge.std__optional_MotionResult_ in
      if let __unwrappedValue = motion {
        return bridge.create_std__optional_MotionResult_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = roiApplied {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = totalPixelsAnalyzed {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }())
  }

  @inline(__always)
  var uniqueColorCount: Double {
    return self.__uniqueColorCount
  }
  
  @inline(__always)
  var topColors: [ColorInfo] {
    return self.__topColors.map({ __item in __item })
  }
  
  @inline(__always)
  var brightestColors: [ColorInfo] {
    return self.__brightestColors.map({ __item in __item })
  }
  
  @inline(__always)
  var motion: MotionResult? {
    return self.__motion.value
  }
  
  @inline(__always)
  var roiApplied: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__roiApplied) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__roiApplied)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var totalPixelsAnalyzed: Double? {
    return self.__totalPixelsAnalyzed.value
  }
}
